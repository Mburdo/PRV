{"id":"PRV-9bw","title":"Phase 1: Core Linking","description":"## North Star\nContext tracing for code. Phase 1 delivers the core value proposition: linking git commits to AI sessions.\n\n## Milestone M1: \"It Links\"\n- PRV can link commits to sessions\n- Accuracy \u003e80% on AI-generated commits\n- Links persist in `.prv/`\n\n## Exit Criteria\n- `prv link --commit HEAD` creates link file\n- `prv query \u003csha\u003e` returns matching session(s) with confidence\n- Manual audit of 50 commits shows \u003e80% accuracy\n- Index rebuild \u003c 30s for repo with 1000 commits\n\n## Requirements\nREQ-002: Commit-session linking (full)\nREQ-005: CLI query (partial)\nREQ-007: Git hook linking (full)\nREQ-008: Index for fast lookup (full)\n\n## Tracks\n- A: Matching Algorithm (.1-.4)\n- B: Link Storage (.5-.7)\n- C: CLI Commands (.8-.9)\n- Integration: Validation (.10)","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-28T18:56:46.994161-05:00","updated_at":"2025-12-28T18:56:46.994161-05:00"}
{"id":"PRV-9bw.1","title":"phase1.1: Workspace gate + time index window","description":"## North Star\nContext tracing for code. Precision-first matching: wrong provenance is worse than Unknown.\n\n**This bead:** Filter sessions by workspace (hard gate) and time window (index bound only).\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/matcher/gates.rs`\n\n**Dependencies:** Add to `crates/prv-core/Cargo.toml`:\n```toml\nchrono = { version = \"0.4\", features = [\"serde\"] }\n```\n\n```rust\nuse prv_cass::{CassDb, Session};\nuse std::path::Path;\nuse chrono::{DateTime, Utc, Duration};\nuse anyhow::Result;\n\n/// Filter sessions that could have produced this commit.\n/// Hard gate: workspace must match. Time window only bounds indexing.\npub fn candidate_sessions(\n    db: \u0026CassDb,\n    repo_path: \u0026Path,\n    commit_time: DateTime\u003cUtc\u003e,\n) -\u003e Result\u003cVec\u003cSession\u003e\u003e {\n    let workspace = db.find_workspace_for_path(repo_path)?;\n\n    let Some(ws) = workspace else {\n        return Ok(vec![]);  // No CASS workspace for this repo\n    };\n\n    let index_window = Duration::days(7);\n\n    let sessions = db.sessions_for_workspace(ws.id)?\n        .into_iter()\n        .filter(|s| {\n            let session_end = s.ended_at.unwrap_or(s.started_at);\n            let start_ok = commit_time + index_window \u003e= s.started_at;\n            let end_ok = commit_time - index_window \u003c= session_end;\n            start_ok \u0026\u0026 end_ok\n        })\n        .collect();\n\n    Ok(sessions)\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_no_workspace_returns_empty() {\n        // Mock db with no matching workspace\n        // Should return Ok(vec![])\n    }\n\n    #[test]\n    fn test_outside_index_window_filtered() {\n        // Session ended 10 days before commit\n        // Should be filtered out\n    }\n\n    #[test]\n    fn test_workspace_mismatch_filtered() {\n        // Session for different workspace\n        // Should not appear in results\n    }\n\n    #[test]\n    fn test_session_in_window_included() {\n        // Session ended 1 hour before commit\n        // Should be included\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail (no implementation yet)\n- [ ] Workspace matching works (case-insensitive on macOS)\n- [ ] Index window bounds candidate set (7 days default)\n- [ ] Returns empty vec (not error) for no matches\n- [ ] `cargo test` passes","status":"closed","priority":1,"issue_type":"task","assignee":"WhiteMountain","created_at":"2025-12-28T18:57:12.67005-05:00","updated_at":"2025-12-28T19:20:26.022711-05:00","closed_at":"2025-12-28T19:20:26.022711-05:00","dependencies":[{"issue_id":"PRV-9bw.1","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T18:57:12.670802-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.10","title":"phase1.10: Corpus validation","description":"## North Star\nContext tracing for code. Validate \u003e80% accuracy on 50-commit corpus.\n\n**This bead:** Integration test against labeled corpus to verify accuracy target.\n\n---\n\n## Workflow\nRun validation after all other Phase 1 beads complete.\n\n---\n\n## Specification\n\n**File:** `scripts/validate_corpus.sh`\n\n```bash\n#!/bin/bash\n# Run step-ladder evaluation on corpus\n\nCORPUS=\"PLAN/support/corpus-v1.jsonl\"\nTOTAL=0\nCORRECT=0\n\nwhile read -r line; do\n    COMMIT=$(echo \"$line\" | jq -r '.commit_sha')\n    EXPECTED=$(echo \"$line\" | jq -r '.session_id')\n\n    # First link the commit\n    prv link --commit \"$COMMIT\" 2\u003e/dev/null\n\n    # Then query it\n    RESULT=$(prv query \"$COMMIT\" --json 2\u003e/dev/null | jq -r '.session_id')\n\n    TOTAL=$((TOTAL + 1))\n    if [ \"$RESULT\" = \"$EXPECTED\" ]; then\n        CORRECT=$((CORRECT + 1))\n        echo \"✓ $COMMIT\"\n    else\n        echo \"✗ $COMMIT (expected $EXPECTED, got $RESULT)\"\n    fi\ndone \u003c \"$CORPUS\"\n\nACCURACY=$(echo \"scale=2; $CORRECT * 100 / $TOTAL\" | bc)\necho \"\"\necho \"Accuracy: $CORRECT / $TOTAL = $ACCURACY%\"\n\nif (( $(echo \"$ACCURACY \u003e= 80\" | bc -l) )); then\n    echo \"✓ PASS: Accuracy target met\"\n    exit 0\nelse\n    echo \"✗ FAIL: Accuracy below 80%\"\n    exit 1\nfi\n```\n\n---\n\n## Success Criteria\n\n- [ ] Accuracy \u003e 80%\n- [ ] Precision \u003e 85% (no false positives)\n- [ ] p95 latency \u003c 100ms per query\n\n---\n\n## Verification Checklist\n- [ ] Script runs against corpus-v1.jsonl\n- [ ] Reports per-commit results\n- [ ] Shows final accuracy percentage\n- [ ] Exits 0 if \u003e= 80%, exits 1 otherwise\n- [ ] Documents any failures for analysis","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-28T19:01:14.057033-05:00","updated_at":"2025-12-28T19:01:14.057033-05:00","dependencies":[{"issue_id":"PRV-9bw.10","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T19:01:14.057802-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.10","depends_on_id":"PRV-9bw.9","type":"blocks","created_at":"2025-12-28T19:02:15.363794-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.2","title":"phase1.2: Step 0 single candidate matching","description":"## North Star\nContext tracing for code. Step 0: when exactly one session passes gates, return with high confidence.\n\n**This bead:** Simplest matching case - single candidate = high confidence match.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/matcher/step0.rs`\n\n```rust\nuse prv_cass::Session;\n\npub struct MatchResult {\n    pub session: Session,\n    pub confidence: f64,\n    pub step: u8,\n}\n\n/// Step 0: If exactly one candidate, return with high confidence.\npub fn match_step0(candidates: \u0026[Session]) -\u003e Option\u003cMatchResult\u003e {\n    if candidates.len() == 1 {\n        Some(MatchResult {\n            session: candidates[0].clone(),\n            confidence: 0.9,\n            step: 0,\n        })\n    } else {\n        None\n    }\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_single_candidate_high_confidence() {\n        let sessions = vec![mock_session(1)];\n        let result = match_step0(\u0026sessions);\n        assert!(result.is_some());\n        assert_eq!(result.unwrap().confidence, 0.9);\n    }\n\n    #[test]\n    fn test_no_candidates_returns_none() {\n        let result = match_step0(\u0026[]);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_multiple_candidates_returns_none() {\n        let sessions = vec![mock_session(1), mock_session(2)];\n        let result = match_step0(\u0026sessions);\n        assert!(result.is_none());\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail\n- [ ] Single candidate returns confidence 0.9\n- [ ] Zero candidates returns None\n- [ ] Multiple candidates returns None (escalates to Step 1)\n- [ ] `cargo test` passes","status":"closed","priority":1,"issue_type":"task","assignee":"WhiteMountain","created_at":"2025-12-28T18:57:33.579622-05:00","updated_at":"2025-12-28T19:24:18.299311-05:00","closed_at":"2025-12-28T19:24:18.299311-05:00","dependencies":[{"issue_id":"PRV-9bw.2","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T18:57:33.580426-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.2","depends_on_id":"PRV-9bw.1","type":"blocks","created_at":"2025-12-28T19:01:29.122423-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.3","title":"phase1.3: Step 1 file path hints","description":"## North Star\nContext tracing for code. Step 1: disambiguate multiple candidates by file path mentions.\n\n**This bead:** When Step 0 returns None (multiple candidates), check file path overlap.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/matcher/step1.rs`\n\n```rust\nuse std::collections::HashSet;\nuse prv_cass::Session;\nuse crate::matcher::MatchResult;\n\n/// Step 1: Disambiguate by file path mentions in session.\npub fn match_step1(\n    candidates: \u0026[Session],\n    commit_files: \u0026[String],\n) -\u003e Option\u003cMatchResult\u003e {\n    let commit_set: HashSet\u003c_\u003e = commit_files.iter().collect();\n\n    for session in candidates {\n        let mentioned = session.file_mentions();\n        let overlap = mentioned.iter()\n            .filter(|f| commit_set.contains(f))\n            .count();\n\n        if overlap \u003e 0 {\n            let bonus = (overlap.min(3) as f64) * 0.05;\n            return Some(MatchResult {\n                session: session.clone(),\n                confidence: 0.85 + bonus,\n                step: 1,\n            });\n        }\n    }\n\n    None\n}\n```\n\n**Requires:** Add `file_mentions()` method to Session in prv-cass.\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_file_overlap_matches() {\n        let session = mock_session_with_files(1, vec![\"src/main.rs\"]);\n        let candidates = vec![session];\n        let result = match_step1(\u0026candidates, \u0026[\"src/main.rs\".to_string()]);\n        assert!(result.is_some());\n        assert!(result.unwrap().confidence \u003e= 0.85);\n    }\n\n    #[test]\n    fn test_no_overlap_returns_none() {\n        let session = mock_session_with_files(1, vec![\"other.rs\"]);\n        let candidates = vec![session];\n        let result = match_step1(\u0026candidates, \u0026[\"src/main.rs\".to_string()]);\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_multiple_overlaps_higher_confidence() {\n        let session = mock_session_with_files(1, vec![\"a.rs\", \"b.rs\", \"c.rs\"]);\n        let candidates = vec![session];\n        let result = match_step1(\u0026candidates, \u0026[\"a.rs\".to_string(), \"b.rs\".to_string()]);\n        assert!(result.unwrap().confidence \u003e 0.85);\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail\n- [ ] File path overlap triggers match\n- [ ] Confidence increases with more overlaps (capped at +0.15)\n- [ ] No overlap returns None (escalates to Step 2)\n- [ ] `cargo test` passes","status":"in_progress","priority":1,"issue_type":"task","assignee":"WhiteMountain","created_at":"2025-12-28T18:58:28.953997-05:00","updated_at":"2025-12-28T19:38:53.973001-05:00","dependencies":[{"issue_id":"PRV-9bw.3","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T18:58:28.955133-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.3","depends_on_id":"PRV-9bw.2","type":"blocks","created_at":"2025-12-28T19:01:34.272648-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.4","title":"phase1.4: Step 2 line hash matching","description":"## North Star\nContext tracing for code. Step 2: disambiguate by normalized line hash overlap.\n\n**This bead:** Match committed lines against session code blocks using normalized hashing.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/matcher/step2.rs`\n\n**Dependencies:** Add to Cargo.toml: `fxhash = \"0.2\"`\n\n```rust\nuse std::collections::HashSet;\nuse fxhash::hash64;\nuse prv_cass::Session;\nuse crate::matcher::MatchResult;\n\nfn hash_normalized(line: \u0026str) -\u003e u64 {\n    let normalized: String = line\n        .trim()\n        .split_whitespace()\n        .collect::\u003cVec\u003c_\u003e\u003e()\n        .join(\" \");\n    hash64(\u0026normalized)\n}\n\npub fn match_step2(\n    candidates: \u0026[Session],\n    diff_lines: \u0026[String],\n) -\u003e Option\u003cMatchResult\u003e {\n    let diff_hashes: HashSet\u003cu64\u003e = diff_lines.iter()\n        .map(|l| hash_normalized(l))\n        .collect();\n\n    let mut best: Option\u003c(Session, f64)\u003e = None;\n\n    for session in candidates {\n        let session_hashes: HashSet\u003cu64\u003e = session.code_block_lines()\n            .map(|l| hash_normalized(\u0026l))\n            .collect();\n\n        let intersection = diff_hashes.intersection(\u0026session_hashes).count();\n        let overlap_ratio = intersection as f64 / diff_hashes.len().max(1) as f64;\n\n        if overlap_ratio \u003e 0.5 {\n            let confidence = 0.8 + (overlap_ratio * 0.2);\n            if best.as_ref().map_or(true, |(_, c)| confidence \u003e *c) {\n                best = Some((session.clone(), confidence));\n            }\n        }\n    }\n\n    best.map(|(session, confidence)| MatchResult {\n        session, confidence, step: 2,\n    })\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_hash_normalized_strips_whitespace() {\n        assert_eq!(hash_normalized(\"  let x = 1;  \"), hash_normalized(\"let x = 1;\"));\n    }\n\n    #[test]\n    fn test_high_overlap_matches() {\n        // Session with 80% matching lines should match\n    }\n\n    #[test]\n    fn test_low_overlap_no_match() {\n        // Session with 30% matching lines should not match\n    }\n\n    #[test]\n    fn test_best_match_selected() {\n        // Multiple candidates, highest overlap wins\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail\n- [ ] Normalization handles whitespace variations\n- [ ] Overlap \u003e 50% triggers match\n- [ ] Best overlap selected among candidates\n- [ ] `cargo test` passes","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-28T18:58:51.69329-05:00","updated_at":"2025-12-28T18:58:51.69329-05:00","dependencies":[{"issue_id":"PRV-9bw.4","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T18:58:51.694036-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.4","depends_on_id":"PRV-9bw.3","type":"blocks","created_at":"2025-12-28T19:01:39.422661-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.5","title":"phase1.5: Link model and serialization","description":"## North Star\nContext tracing for code. Link model persists commit→session associations.\n\n**This bead:** Define Link struct with serialization for JSON persistence.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/link.rs`\n\n**Dependencies:** Add to Cargo.toml:\n```toml\nserde = { version = \"1\", features = [\"derive\"] }\nserde_json = \"1\"\nchrono = { version = \"0.4\", features = [\"serde\"] }\n```\n\n```rust\nuse serde::{Serialize, Deserialize};\nuse chrono::{DateTime, Utc};\n\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]\npub struct Link {\n    pub commit_sha: String,\n    pub session_id: i64,\n    pub confidence: f64,\n    pub match_step: u8,\n    pub created_at: DateTime\u003cUtc\u003e,\n}\n\nimpl Link {\n    pub fn new(commit_sha: \u0026str, session_id: i64, confidence: f64, step: u8) -\u003e Self {\n        Self {\n            commit_sha: commit_sha.to_string(),\n            session_id,\n            confidence,\n            match_step: step,\n            created_at: Utc::now(),\n        }\n    }\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_link_new() {\n        let link = Link::new(\"abc123\", 42, 0.9, 0);\n        assert_eq!(link.commit_sha, \"abc123\");\n        assert_eq!(link.session_id, 42);\n        assert_eq!(link.confidence, 0.9);\n    }\n\n    #[test]\n    fn test_link_serialization() {\n        let link = Link::new(\"abc123\", 42, 0.9, 0);\n        let json = serde_json::to_string(\u0026link).unwrap();\n        let parsed: Link = serde_json::from_str(\u0026json).unwrap();\n        assert_eq!(link.commit_sha, parsed.commit_sha);\n    }\n\n    #[test]\n    fn test_link_equality() {\n        let a = Link::new(\"abc\", 1, 0.9, 0);\n        let b = Link::new(\"abc\", 1, 0.9, 0);\n        // Note: created_at differs, so equality check\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail\n- [ ] Link struct derives all required traits\n- [ ] JSON round-trip works\n- [ ] `cargo build` succeeds\n- [ ] `cargo test` passes","status":"closed","priority":1,"issue_type":"task","assignee":"RedMountain","created_at":"2025-12-28T18:59:20.262679-05:00","updated_at":"2025-12-28T19:12:12.263233-05:00","closed_at":"2025-12-28T19:12:12.263233-05:00","dependencies":[{"issue_id":"PRV-9bw.5","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T18:59:20.263377-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.6","title":"phase1.6: Link persistence to .prv/links/","description":"## North Star\nContext tracing for code. Persist links to `.prv/links/` for retrieval.\n\n**This bead:** Write/read link JSON files organized by commit SHA prefix.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/link_storage.rs`\n\n```rust\nuse crate::link::Link;\nuse std::path::{Path, PathBuf};\nuse anyhow::Result;\n\npub struct LinkStorage {\n    base_path: PathBuf,\n}\n\nimpl LinkStorage {\n    pub fn new(repo_root: \u0026Path) -\u003e Self {\n        Self {\n            base_path: repo_root.join(\".prv\").join(\"links\"),\n        }\n    }\n\n    fn link_path(\u0026self, commit_sha: \u0026str) -\u003e PathBuf {\n        let prefix = \u0026commit_sha[..2];\n        self.base_path.join(prefix).join(format!(\"{}.json\", commit_sha))\n    }\n\n    pub fn save(\u0026self, link: \u0026Link) -\u003e Result\u003c()\u003e {\n        let path = self.link_path(\u0026link.commit_sha);\n        std::fs::create_dir_all(path.parent().unwrap())?;\n        let json = serde_json::to_string_pretty(link)?;\n        std::fs::write(\u0026path, json)?;\n        Ok(())\n    }\n\n    pub fn load(\u0026self, commit_sha: \u0026str) -\u003e Result\u003cOption\u003cLink\u003e\u003e {\n        let path = self.link_path(commit_sha);\n        if !path.exists() {\n            return Ok(None);\n        }\n        let json = std::fs::read_to_string(\u0026path)?;\n        let link: Link = serde_json::from_str(\u0026json)?;\n        Ok(Some(link))\n    }\n\n    pub fn exists(\u0026self, commit_sha: \u0026str) -\u003e bool {\n        self.link_path(commit_sha).exists()\n    }\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_save_and_load() {\n        let tmp = TempDir::new().unwrap();\n        let storage = LinkStorage::new(tmp.path());\n        let link = Link::new(\"abc123def\", 42, 0.9, 0);\n        \n        storage.save(\u0026link).unwrap();\n        let loaded = storage.load(\"abc123def\").unwrap();\n        \n        assert!(loaded.is_some());\n        assert_eq!(loaded.unwrap().session_id, 42);\n    }\n\n    #[test]\n    fn test_load_nonexistent() {\n        let tmp = TempDir::new().unwrap();\n        let storage = LinkStorage::new(tmp.path());\n        let result = storage.load(\"nonexistent\").unwrap();\n        assert!(result.is_none());\n    }\n\n    #[test]\n    fn test_path_structure() {\n        let tmp = TempDir::new().unwrap();\n        let storage = LinkStorage::new(tmp.path());\n        let path = storage.link_path(\"abcdef123\");\n        assert!(path.to_string_lossy().contains(\"ab/abcdef123.json\"));\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail\n- [ ] Creates .prv/links/XX/ directory structure\n- [ ] Save creates pretty-printed JSON\n- [ ] Load returns None for missing files\n- [ ] `cargo test` passes","status":"closed","priority":1,"issue_type":"task","assignee":"RedMountain","created_at":"2025-12-28T18:59:42.398064-05:00","updated_at":"2025-12-28T19:20:04.514087-05:00","closed_at":"2025-12-28T19:20:04.514087-05:00","dependencies":[{"issue_id":"PRV-9bw.6","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T18:59:42.399038-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.6","depends_on_id":"PRV-9bw.5","type":"blocks","created_at":"2025-12-28T19:01:44.570701-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.7","title":"phase1.7: Link index for fast lookup","description":"## North Star\nContext tracing for code. Fast O(1) lookup of commit→session mapping.\n\n**This bead:** In-memory index with disk persistence for quick queries.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/link_index.rs`\n\n```rust\nuse crate::link::Link;\nuse std::collections::HashMap;\nuse std::path::Path;\nuse anyhow::Result;\n\npub struct LinkIndex {\n    index: HashMap\u003cString, i64\u003e,\n}\n\nimpl LinkIndex {\n    pub fn new() -\u003e Self {\n        Self { index: HashMap::new() }\n    }\n\n    pub fn load(repo_root: \u0026Path) -\u003e Result\u003cSelf\u003e {\n        let index_path = repo_root.join(\".prv\").join(\"index.json\");\n        if !index_path.exists() {\n            return Ok(Self::new());\n        }\n        let json = std::fs::read_to_string(\u0026index_path)?;\n        let index: HashMap\u003cString, i64\u003e = serde_json::from_str(\u0026json)?;\n        Ok(Self { index })\n    }\n\n    pub fn save(\u0026self, repo_root: \u0026Path) -\u003e Result\u003c()\u003e {\n        let index_path = repo_root.join(\".prv\").join(\"index.json\");\n        std::fs::create_dir_all(index_path.parent().unwrap())?;\n        let json = serde_json::to_string(\u0026self.index)?;\n        std::fs::write(\u0026index_path, json)?;\n        Ok(())\n    }\n\n    pub fn insert(\u0026mut self, link: \u0026Link) {\n        self.index.insert(link.commit_sha.clone(), link.session_id);\n    }\n\n    pub fn get(\u0026self, commit_sha: \u0026str) -\u003e Option\u003ci64\u003e {\n        self.index.get(commit_sha).copied()\n    }\n\n    pub fn len(\u0026self) -\u003e usize {\n        self.index.len()\n    }\n\n    pub fn is_empty(\u0026self) -\u003e bool {\n        self.index.is_empty()\n    }\n}\n\nimpl Default for LinkIndex {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use tempfile::TempDir;\n\n    #[test]\n    fn test_insert_and_get() {\n        let mut index = LinkIndex::new();\n        let link = Link::new(\"abc123\", 42, 0.9, 0);\n        index.insert(\u0026link);\n        assert_eq!(index.get(\"abc123\"), Some(42));\n    }\n\n    #[test]\n    fn test_save_and_load() {\n        let tmp = TempDir::new().unwrap();\n        let mut index = LinkIndex::new();\n        index.insert(\u0026Link::new(\"abc\", 1, 0.9, 0));\n        index.save(tmp.path()).unwrap();\n\n        let loaded = LinkIndex::load(tmp.path()).unwrap();\n        assert_eq!(loaded.get(\"abc\"), Some(1));\n    }\n\n    #[test]\n    fn test_load_empty() {\n        let tmp = TempDir::new().unwrap();\n        let index = LinkIndex::load(tmp.path()).unwrap();\n        assert!(index.is_empty());\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail\n- [ ] O(1) lookup via HashMap\n- [ ] Persists to .prv/index.json\n- [ ] Loads empty index if file missing\n- [ ] `cargo test` passes","status":"closed","priority":1,"issue_type":"task","assignee":"RedMountain","created_at":"2025-12-28T19:00:06.104173-05:00","updated_at":"2025-12-28T19:23:13.362822-05:00","closed_at":"2025-12-28T19:23:13.362822-05:00","dependencies":[{"issue_id":"PRV-9bw.7","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T19:00:06.104969-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.7","depends_on_id":"PRV-9bw.6","type":"blocks","created_at":"2025-12-28T19:01:49.708606-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.8","title":"phase1.8: prv link command","description":"## North Star\nContext tracing for code. CLI command to link commits to sessions.\n\n**This bead:** `prv link --commit HEAD` finds and persists session association.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv/src/commands/link.rs`\n\n**Dependencies:** Add to Cargo.toml: `git2 = \"0.18\"`\n\n```rust\nuse clap::Args;\nuse anyhow::Result;\nuse prv_core::{Link, LinkStorage, LinkIndex, matcher};\nuse prv_cass::CassDb;\n\n#[derive(Args)]\npub struct LinkArgs {\n    #[arg(long, default_value = \"HEAD\")]\n    commit: String,\n\n    #[arg(long)]\n    all: bool,\n}\n\npub fn run(args: LinkArgs) -\u003e Result\u003c()\u003e {\n    let repo = git2::Repository::open_from_env()?;\n    let cass = CassDb::open()?;\n    let storage = LinkStorage::new(repo.workdir().unwrap());\n    let mut index = LinkIndex::load(repo.workdir().unwrap())?;\n\n    let commit_sha = resolve_commit(\u0026repo, \u0026args.commit)?;\n    let commit = repo.find_commit(git2::Oid::from_str(\u0026commit_sha)?)?;\n\n    let changed_files = get_changed_files(\u0026repo, \u0026commit)?;\n    let diff_lines = get_diff_lines(\u0026repo, \u0026commit)?;\n\n    let result = matcher::find_session(\n        \u0026cass,\n        repo.workdir().unwrap(),\n        commit.time(),\n        \u0026changed_files,\n        \u0026diff_lines,\n    )?;\n\n    match result {\n        Some(m) =\u003e {\n            let link = Link::new(\u0026commit_sha, m.session.id, m.confidence, m.step);\n            storage.save(\u0026link)?;\n            index.insert(\u0026link);\n            index.save(repo.workdir().unwrap())?;\n            println!(\"Linked {} → session {} ({:.0}%)\",\n                \u0026commit_sha[..7], m.session.id, m.confidence * 100.0);\n        }\n        None =\u003e println!(\"No matching session for {}\", \u0026commit_sha[..7]),\n    }\n    Ok(())\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[test]\nfn test_cli_parses_link_args() {\n    // Verify clap parsing works\n}\n\n#[test]\n#[ignore]\nfn test_link_creates_file() {\n    // Integration test: run prv link, check .prv/links/ exists\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] `prv link` works with no args (defaults to HEAD)\n- [ ] `prv link --commit \u003csha\u003e` works\n- [ ] Creates .prv/links/XX/sha.json\n- [ ] Updates .prv/index.json\n- [ ] Shows confidence and step in output","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-28T19:00:33.200647-05:00","updated_at":"2025-12-28T19:00:33.200647-05:00","dependencies":[{"issue_id":"PRV-9bw.8","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T19:00:33.20138-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.8","depends_on_id":"PRV-9bw.4","type":"blocks","created_at":"2025-12-28T19:01:54.847508-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.8","depends_on_id":"PRV-9bw.6","type":"blocks","created_at":"2025-12-28T19:01:59.98445-05:00","created_by":"burdo"}]}
{"id":"PRV-9bw.9","title":"phase1.9: prv query command","description":"## North Star\nContext tracing for code. CLI command to query session for a commit.\n\n**This bead:** `prv query \u003csha\u003e` returns linked session with confidence.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv/src/commands/query.rs`\n\n```rust\nuse clap::Args;\nuse anyhow::Result;\nuse prv_core::LinkStorage;\nuse prv_cass::CassDb;\n\n#[derive(Args)]\npub struct QueryArgs {\n    commit: String,\n\n    #[arg(long)]\n    json: bool,\n}\n\npub fn run(args: QueryArgs) -\u003e Result\u003c()\u003e {\n    let repo = git2::Repository::open_from_env()?;\n    let storage = LinkStorage::new(repo.workdir().unwrap());\n    let cass = CassDb::open()?;\n\n    let commit_sha = resolve_commit(\u0026repo, \u0026args.commit)?;\n\n    if let Some(link) = storage.load(\u0026commit_sha)? {\n        let session = cass.get_session(link.session_id)?;\n\n        if args.json {\n            println!(\"{}\", serde_json::to_string_pretty(\u0026link)?);\n        } else {\n            println!(\"Commit: {}\", \u0026commit_sha[..7]);\n            println!(\"Session: {} ({})\", link.session_id, \n                session.title.unwrap_or_default());\n            println!(\"Confidence: {:.0}%\", link.confidence * 100.0);\n            println!(\"Match step: {}\", link.match_step);\n        }\n    } else {\n        println!(\"No link found for {}. Run `prv link` first.\", \u0026commit_sha[..7]);\n    }\n    Ok(())\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[test]\nfn test_cli_parses_query_args() {\n    // Verify clap parsing\n}\n\n#[test]\nfn test_json_output_format() {\n    // Verify JSON output is valid\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] `prv query \u003csha\u003e` shows human-readable output\n- [ ] `prv query \u003csha\u003e --json` outputs valid JSON\n- [ ] Shows helpful message when no link exists\n- [ ] Resolves HEAD, branch names, short SHAs","status":"in_progress","priority":1,"issue_type":"task","assignee":"RedMountain","created_at":"2025-12-28T19:00:53.315816-05:00","updated_at":"2025-12-28T19:38:55.655269-05:00","dependencies":[{"issue_id":"PRV-9bw.9","depends_on_id":"PRV-9bw","type":"parent-child","created_at":"2025-12-28T19:00:53.316601-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.9","depends_on_id":"PRV-9bw.7","type":"blocks","created_at":"2025-12-28T19:02:05.106522-05:00","created_by":"burdo"},{"issue_id":"PRV-9bw.9","depends_on_id":"PRV-9bw.8","type":"blocks","created_at":"2025-12-28T19:02:10.233538-05:00","created_by":"burdo"}]}
{"id":"PRV-pcy","title":"SPIKE-002 corpus + scoring rubric","description":"Build corpus + methodology + scoring rubric for SPIKE-002; produce ~50 commit↔session pairs and step-ladder evaluation plan/results. Also update planning docs to support v1 minimal live overlay (provisional matching) and reflect time-prior scoring.","status":"closed","priority":1,"issue_type":"task","assignee":"LilacDog","estimated_minutes":180,"created_at":"2025-12-28T16:19:33.957864-05:00","updated_at":"2025-12-28T18:50:44.471594-05:00","closed_at":"2025-12-28T18:50:44.471594-05:00"}
{"id":"PRV-u0f","title":"Phase 0: Foundation","description":"Establish build system, CASS integration, and basic data flow. Exit criteria: cargo build produces prv binary, prv debug cass shows session count, unit tests pass for code block parser.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-27T22:44:07.432156-05:00","updated_at":"2025-12-28T12:22:43.826278-05:00","closed_at":"2025-12-28T12:22:43.826278-05:00"}
{"id":"PRV-u0f.1","title":"phase0.1: Cargo workspace setup","description":"Create Rust cargo workspace structure:\n- Root Cargo.toml with workspace members: prv, prv-core, prv-cass\n- .gitignore for Rust artifacts\n- crates/ directory with subdirectories for each crate\n\nFiles:\n- Cargo.toml (workspace root)\n- .gitignore\n- crates/prv/Cargo.toml\n- crates/prv-core/Cargo.toml  \n- crates/prv-cass/Cargo.toml\n\nVerification: cargo build succeeds (even if crates are empty stubs)","status":"closed","priority":1,"issue_type":"task","assignee":"BlackCat","created_at":"2025-12-27T22:44:21.587895-05:00","updated_at":"2025-12-28T12:15:05.385983-05:00","closed_at":"2025-12-28T12:15:05.385983-05:00","dependencies":[{"issue_id":"PRV-u0f.1","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:44:21.588581-05:00","created_by":"burdo"}]}
{"id":"PRV-u0f.2","title":"phase0.2: prv-core CodeBlock struct","description":"## North Star\nContext tracing for code. Trace any line back to its origin, the reasoning behind it, and alternatives rejected.\n\n**This bead:** Foundation data structure for extracted code blocks.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/code_block.rs`\n\n```rust\n#[derive(Debug, Clone, PartialEq)]\npub struct CodeBlock {\n    pub content: String,\n    pub language: Option\u003cString\u003e,\n    pub source_line: usize,\n}\n\nimpl CodeBlock {\n    pub fn new(content: String, language: Option\u003cString\u003e, source_line: usize) -\u003e Self {\n        Self { content, language, source_line }\n    }\n}\n```\n\n**File:** `crates/prv-core/src/lib.rs`\n```rust\npub mod code_block;\npub use code_block::CodeBlock;\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_code_block_new() {\n        let block = CodeBlock::new(\"fn main() {}\".to_string(), Some(\"rust\".to_string()), 10);\n        assert_eq!(block.content, \"fn main() {}\");\n        assert_eq!(block.language, Some(\"rust\".to_string()));\n        assert_eq!(block.source_line, 10);\n    }\n\n    #[test]\n    fn test_code_block_no_language() {\n        let block = CodeBlock::new(\"code\".to_string(), None, 1);\n        assert!(block.language.is_none());\n    }\n\n    #[test]\n    fn test_code_block_equality() {\n        let a = CodeBlock::new(\"x\".to_string(), None, 1);\n        let b = CodeBlock::new(\"x\".to_string(), None, 1);\n        assert_eq!(a, b);\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail (no implementation yet)\n- [ ] `cargo build` succeeds\n- [ ] `cargo test` passes (3 tests)\n- [ ] CodeBlock is public and usable from prv-core","status":"closed","priority":1,"issue_type":"task","assignee":"TrackA","created_at":"2025-12-27T22:44:34.800209-05:00","updated_at":"2025-12-28T12:17:16.447043-05:00","closed_at":"2025-12-28T12:17:16.447043-05:00","dependencies":[{"issue_id":"PRV-u0f.2","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:44:34.800817-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.2","depends_on_id":"PRV-u0f.1","type":"blocks","created_at":"2025-12-27T22:46:44.848477-05:00","created_by":"burdo"}]}
{"id":"PRV-u0f.3","title":"phase0.3: Code block parser","description":"## North Star\nContext tracing for code. PRV extracts code blocks from CASS messages for fingerprinting against commits.\n\n**This bead:** Core parsing logic to extract code from AI session transcripts.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-core/src/code_block.rs`\n\n**Dependencies:** Add `regex = \"1\"` to `crates/prv-core/Cargo.toml`\n\n```rust\nuse regex::Regex;\n\n/// Extract all code blocks from markdown-style text\npub fn extract_code_blocks(text: \u0026str) -\u003e Vec\u003cCodeBlock\u003e {\n    let mut blocks = Vec::new();\n    \n    // 1. Triple backtick blocks: ```lang\\ncode\\n```\n    let re = Regex::new(r\"```(\\w*)\\n([\\s\\S]*?)```\").unwrap();\n    for (line_num, cap) in re.captures_iter(text).enumerate() {\n        let lang = cap.get(1).map(|m| m.as_str().to_string()).filter(|s| !s.is_empty());\n        let content = cap.get(2).map(|m| m.as_str().to_string()).unwrap_or_default();\n        blocks.push(CodeBlock::new(content, lang, line_num));\n    }\n    \n    // 2. 4-space indented blocks (simplified - consecutive indented lines)\n    // 3. Diff format (+lines)\n    \n    blocks\n}\n```\n\n**Note:** Full implementation handles edge cases. This shows the pattern.\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_triple_backtick_basic() {\n        let text = \"```\\nfn main() {}\\n```\";\n        let blocks = extract_code_blocks(text);\n        assert_eq!(blocks.len(), 1);\n        assert_eq!(blocks[0].content, \"fn main() {}\\n\");\n    }\n\n    #[test]\n    fn test_triple_backtick_with_language() {\n        let text = \"```rust\\nlet x = 1;\\n```\";\n        let blocks = extract_code_blocks(text);\n        assert_eq!(blocks[0].language, Some(\"rust\".to_string()));\n    }\n\n    #[test]\n    fn test_multiple_blocks() {\n        let text = \"```python\\nprint(1)\\n```\\ntext\\n```js\\nconsole.log(1)\\n```\";\n        let blocks = extract_code_blocks(text);\n        assert_eq!(blocks.len(), 2);\n    }\n\n    #[test]\n    fn test_empty_input() {\n        let blocks = extract_code_blocks(\"\");\n        assert!(blocks.is_empty());\n    }\n\n    #[test]\n    fn test_no_code_blocks() {\n        let blocks = extract_code_blocks(\"just plain text\");\n        assert!(blocks.is_empty());\n    }\n\n    #[test]\n    fn test_unclosed_block() {\n        let text = \"```rust\\nlet x = 1;\";\n        let blocks = extract_code_blocks(text);\n        // Should not crash, may return 0 or partial\n        assert!(blocks.len() \u003c= 1);\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail (no implementation yet)\n- [ ] `cargo build` succeeds\n- [ ] `cargo test` passes (6 tests)\n- [ ] Handles malformed input without panic","status":"closed","priority":1,"issue_type":"task","assignee":"TrackA","created_at":"2025-12-27T22:44:49.346901-05:00","updated_at":"2025-12-28T12:18:24.229095-05:00","closed_at":"2025-12-28T12:18:24.229095-05:00","dependencies":[{"issue_id":"PRV-u0f.3","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:44:49.347939-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.3","depends_on_id":"PRV-u0f.2","type":"blocks","created_at":"2025-12-27T22:46:49.990514-05:00","created_by":"burdo"}]}
{"id":"PRV-u0f.4","title":"phase0.4: Code block parser tests","description":"Unit tests for code block parser:\n\nFile: crates/prv-core/src/code_block.rs (inline tests) or tests/code_block_test.rs\n\nTests:\n1. test_triple_backtick_basic - extracts simple code block\n2. test_triple_backtick_with_language - extracts language tag\n3. test_multiple_blocks - extracts all blocks from text\n4. test_4space_indent - extracts indented code\n5. test_diff_format - extracts + lines from unified diff\n6. test_malformed_unclosed - handles unclosed block gracefully\n7. test_nested_blocks - handles nested backticks\n8. test_empty_input - returns empty vec\n\nVerification: cargo test passes","status":"closed","priority":1,"issue_type":"task","assignee":"TrackA","created_at":"2025-12-27T22:45:04.049102-05:00","updated_at":"2025-12-28T12:19:54.973711-05:00","closed_at":"2025-12-28T12:19:54.973711-05:00","dependencies":[{"issue_id":"PRV-u0f.4","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:45:04.049992-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.4","depends_on_id":"PRV-u0f.3","type":"blocks","created_at":"2025-12-27T22:46:55.133709-05:00","created_by":"burdo"}]}
{"id":"PRV-u0f.5","title":"phase0.5: prv-cass models","description":"## North Star\nContext tracing for code. PRV reads session data from CASS SQLite to correlate with git commits.\n\n**This bead:** Data models matching CASS database schema.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-cass/src/models.rs`\n\n```rust\n#[derive(Debug, Clone)]\npub struct Workspace {\n    pub id: i64,\n    pub path: String,\n}\n\n#[derive(Debug, Clone)]\npub struct Conversation {\n    pub id: i64,\n    pub workspace_id: i64,\n    pub started_at: i64,      // Unix ms\n    pub ended_at: Option\u003ci64\u003e,\n    pub title: Option\u003cString\u003e,\n    pub source_path: Option\u003cString\u003e,\n}\n\n#[derive(Debug, Clone)]\npub struct Message {\n    pub id: i64,\n    pub conversation_id: i64,\n    pub role: String,         // \"user\" or \"assistant\"\n    pub content: String,\n    pub created_at: i64,      // Unix ms\n}\n```\n\n**File:** `crates/prv-cass/src/lib.rs`\n```rust\npub mod models;\npub mod db;\npub mod workspace;\n\npub use models::{Workspace, Conversation, Message};\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_workspace_creation() {\n        let ws = Workspace { id: 1, path: \"/home/user/project\".to_string() };\n        assert_eq!(ws.id, 1);\n    }\n\n    #[test]\n    fn test_conversation_optional_fields() {\n        let conv = Conversation {\n            id: 1, workspace_id: 1, started_at: 1000, ended_at: None,\n            title: None, source_path: None,\n        };\n        assert!(conv.ended_at.is_none());\n    }\n\n    #[test]\n    fn test_message_roles() {\n        let msg = Message {\n            id: 1, conversation_id: 1, role: \"assistant\".to_string(),\n            content: \"Hello\".to_string(), created_at: 1000,\n        };\n        assert_eq!(msg.role, \"assistant\");\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail (no implementation yet)\n- [ ] `cargo build` succeeds\n- [ ] Models match CASS schema (verified in SPIKE-001)\n- [ ] All structs derive Debug, Clone","status":"closed","priority":1,"issue_type":"task","assignee":"TrackB","created_at":"2025-12-27T22:45:16.91049-05:00","updated_at":"2025-12-28T12:17:22.440121-05:00","closed_at":"2025-12-28T12:17:22.440121-05:00","dependencies":[{"issue_id":"PRV-u0f.5","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:45:16.911155-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.5","depends_on_id":"PRV-u0f.1","type":"blocks","created_at":"2025-12-27T22:47:00.274803-05:00","created_by":"burdo"}]}
{"id":"PRV-u0f.6","title":"phase0.6: CASS database connection","description":"## North Star\nContext tracing for code. PRV reads from CASS SQLite database (ADR-006).\n\n**This bead:** Database connection and query layer for CASS.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**Dependencies:** Add to `crates/prv-cass/Cargo.toml`:\n```toml\nrusqlite = { version = \"0.31\", features = [\"bundled\"] }\nanyhow = \"1\"\ndirs = \"5\"\n```\n\n**File:** `crates/prv-cass/src/db.rs`\n\n```rust\nuse anyhow::{Result, Context};\nuse rusqlite::Connection;\nuse crate::models::{Workspace, Conversation, Message};\n\npub struct CassDb {\n    conn: Connection,\n}\n\nimpl CassDb {\n    /// Open CASS database at default location\n    pub fn open() -\u003e Result\u003cSelf\u003e {\n        let path = Self::default_path()?;\n        let conn = Connection::open(\u0026path)\n            .with_context(|| format\\!(\"Failed to open CASS db at {:?}\", path))?;\n        Ok(Self { conn })\n    }\n\n    fn default_path() -\u003e Result\u003cstd::path::PathBuf\u003e {\n        let support = dirs::data_dir()\n            .context(\"Could not find Application Support directory\")?;\n        Ok(support\n            .join(\"com.coding-agent-search.coding-agent-search\")\n            .join(\"agent_search.db\"))\n    }\n\n    pub fn session_count(\u0026self) -\u003e Result\u003ci64\u003e {\n        let count: i64 = self.conn.query_row(\n            \"SELECT COUNT(*) FROM conversations\", [], |row| row.get(0)\n        )?;\n        Ok(count)\n    }\n\n    pub fn workspaces(\u0026self) -\u003e Result\u003cVec\u003cWorkspace\u003e\u003e {\n        let mut stmt = self.conn.prepare(\"SELECT id, path FROM workspaces\")?;\n        let rows = stmt.query_map([], |row| {\n            Ok(Workspace { id: row.get(0)?, path: row.get(1)? })\n        })?;\n        rows.collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e().map_err(Into::into)\n    }\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_path_exists() {\n        // Just verify path construction doesn't panic\n        let result = CassDb::default_path();\n        assert\\!(result.is_ok());\n    }\n\n    #[test]\n    fn test_open_missing_db() {\n        // If CASS not installed, should get clear error\n        let result = CassDb::open();\n        // Either succeeds or fails with context\n        match result {\n            Ok(_) =\u003e (), // CASS installed\n            Err(e) =\u003e assert\\!(e.to_string().contains(\"CASS\") || e.to_string().contains(\"agent_search\")),\n        }\n    }\n\n    // Integration test (requires CASS):\n    #[test]\n    #[ignore] // Run with: cargo test -- --ignored\n    fn test_session_count() {\n        let db = CassDb::open().unwrap();\n        let count = db.session_count().unwrap();\n        assert\\!(count \u003e= 0);\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail (no implementation yet)\n- [ ] `cargo build` succeeds\n- [ ] Clear error message if CASS not installed\n- [ ] `cargo test -- --ignored` passes with CASS present","status":"closed","priority":1,"issue_type":"task","assignee":"TrackB","created_at":"2025-12-27T22:45:31.642545-05:00","updated_at":"2025-12-28T12:18:35.120844-05:00","closed_at":"2025-12-28T12:18:35.120844-05:00","dependencies":[{"issue_id":"PRV-u0f.6","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:45:31.643222-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.6","depends_on_id":"PRV-u0f.5","type":"blocks","created_at":"2025-12-27T22:47:05.398218-05:00","created_by":"burdo"}]}
{"id":"PRV-u0f.7","title":"phase0.7: Workspace-repo mapping","description":"## North Star\nContext tracing for code. PRV maps git repos to CASS workspaces (REQ-004).\n\n**This bead:** Find which CASS workspace matches a git repository path.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv-cass/src/workspace.rs`\n\n```rust\nuse std::path::Path;\nuse anyhow::Result;\nuse crate::{CassDb, Workspace};\n\n/// Find CASS workspace matching a git repo path\npub fn find_workspace_for_repo(db: \u0026CassDb, repo_path: \u0026Path) -\u003e Result\u003cOption\u003cWorkspace\u003e\u003e {\n    let canonical = repo_path.canonicalize()?;\n    let repo_str = canonical.to_string_lossy();\n    \n    for ws in db.workspaces()? {\n        let ws_path = Path::new(\u0026ws.path);\n        if let Ok(ws_canonical) = ws_path.canonicalize() {\n            // Case-insensitive on macOS\n            #[cfg(target_os = \"macos\")]\n            let matches = ws_canonical.to_string_lossy().to_lowercase() \n                == repo_str.to_lowercase();\n            \n            #[cfg(not(target_os = \"macos\"))]\n            let matches = ws_canonical == canonical;\n            \n            if matches {\n                return Ok(Some(ws));\n            }\n        }\n    }\n    Ok(None)\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    #[test]\n    fn test_path_with_trailing_slash() {\n        let p1 = PathBuf::from(\"/foo/bar\");\n        let p2 = PathBuf::from(\"/foo/bar/\");\n        // canonicalize strips trailing slash\n    }\n\n    #[test]\n    #[ignore] // Requires CASS\n    fn test_find_workspace_real() {\n        let db = CassDb::open().unwrap();\n        let cwd = std::env::current_dir().unwrap();\n        let result = find_workspace_for_repo(\u0026db, \u0026cwd);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_nonexistent_path() {\n        let path = Path::new(\"/nonexistent/path/12345\");\n        assert!(path.canonicalize().is_err());\n    }\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail (no implementation yet)\n- [ ] Handles trailing slashes\n- [ ] Handles symlinks (via canonicalize)\n- [ ] Case-insensitive on macOS\n- [ ] Returns None for unmatched paths (not error)","status":"closed","priority":1,"issue_type":"task","assignee":"TrackB","created_at":"2025-12-27T22:45:44.987758-05:00","updated_at":"2025-12-28T12:19:42.891644-05:00","closed_at":"2025-12-28T12:19:42.891644-05:00","dependencies":[{"issue_id":"PRV-u0f.7","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:45:44.988506-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.7","depends_on_id":"PRV-u0f.6","type":"blocks","created_at":"2025-12-27T22:47:10.52514-05:00","created_by":"burdo"}]}
{"id":"PRV-u0f.8","title":"phase0.8: CLI binary with clap","description":"## North Star\nContext tracing for code. LSP is primary interface (ADR-008), CLI is secondary.\n\n**This bead:** CLI entry point with clap argument parsing.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**Dependencies:** Add to `crates/prv/Cargo.toml`:\n```toml\nclap = { version = \"4\", features = [\"derive\"] }\nprv-core = { path = \"../prv-core\" }\nprv-cass = { path = \"../prv-cass\" }\nanyhow = \"1\"\n```\n\n**File:** `crates/prv/src/main.rs`\n\n```rust\nuse clap::{Parser, Subcommand};\nuse anyhow::Result;\n\n#[derive(Parser)]\n#[command(name = \"prv\")]\n#[command(version, about = \"Context tracing for code\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Option\u003cCommands\u003e,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Debug utilities\n    Debug {\n        #[command(subcommand)]\n        debug_cmd: DebugCommands,\n    },\n}\n\n#[derive(Subcommand)]\nenum DebugCommands {\n    /// Show CASS database status\n    Cass,\n}\n\nfn main() -\u003e Result\u003c()\u003e {\n    let cli = Cli::parse();\n    \n    match cli.command {\n        Some(Commands::Debug { debug_cmd }) =\u003e match debug_cmd {\n            DebugCommands::Cass =\u003e {\n                println!(\"CASS debug (not yet implemented)\");\n            }\n        },\n        None =\u003e {\n            println!(\"prv: context tracing for code\");\n            println!(\"Run with --help for usage\");\n        }\n    }\n    \n    Ok(())\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n#[test]\nfn test_cli_parses() {\n    use clap::CommandFactory;\n    Cli::command().debug_assert();\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail (no implementation yet)\n- [ ] `cargo build` produces `prv` binary\n- [ ] `prv --version` shows version\n- [ ] `prv --help` shows help with debug subcommand\n- [ ] `prv debug cass` runs (placeholder ok)","status":"closed","priority":1,"issue_type":"task","assignee":"TrackC","created_at":"2025-12-27T22:45:58.067236-05:00","updated_at":"2025-12-28T12:17:14.526882-05:00","closed_at":"2025-12-28T12:17:14.526882-05:00","dependencies":[{"issue_id":"PRV-u0f.8","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:45:58.067886-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.8","depends_on_id":"PRV-u0f.1","type":"blocks","created_at":"2025-12-27T22:47:15.64591-05:00","created_by":"burdo"}]}
{"id":"PRV-u0f.9","title":"phase0.9: prv debug cass command","description":"## North Star\nContext tracing for code. This command validates Phase 0 integration - CASS reading + code block parsing.\n\n**This bead:** Integration command that proves all Phase 0 components work together.\n\n---\n\n## Workflow\n**TDD:** Write tests first → Run (expect fail) → Implement → Run (expect pass)\n\n---\n\n## Specification\n\n**File:** `crates/prv/src/main.rs` (extend DebugCommands::Cass handler)\n\n```rust\nDebugCommands::Cass =\u003e {\n    use prv_cass::CassDb;\n    use prv_core::code_block::extract_code_blocks;\n    \n    match CassDb::open() {\n        Ok(db) =\u003e {\n            let count = db.session_count()?;\n            let workspaces = db.workspaces()?;\n            \n            println!(\"CASS Database Status\");\n            println!(\"====================\");\n            println!(\"Location: ~/Library/Application Support/.../agent_search.db\");\n            println!(\"Status: Connected\");\n            println!(\"Workspaces: {}\", workspaces.len());\n            println!(\"Sessions: {}\", count);\n            \n            // Sample code block extraction from recent message\n            if let Some(msg) = get_recent_message(\u0026db)? {\n                let blocks = extract_code_blocks(\u0026msg.content);\n                println!(\"\\nSample extraction ({} blocks from recent message):\", blocks.len());\n                if let Some(block) = blocks.first() {\n                    let preview = block.content.lines().take(3).collect::\u003cVec\u003c_\u003e\u003e().join(\"\\n\");\n                    println!(\"  Language: {:?}\", block.language);\n                    println!(\"  Preview:\\n    {}\", preview.replace(\"\\n\", \"\\n    \"));\n                }\n            }\n        }\n        Err(e) =\u003e {\n            eprintln!(\"CASS not available: {}\", e);\n            eprintln!(\"\\nIs CASS installed? See: https://github.com/...\");\n            std::process::exit(1);\n        }\n    }\n}\n```\n\n---\n\n## Tests (Write First)\n\n```rust\n// Integration test - requires CASS\n#[test]\n#[ignore]\nfn test_debug_cass_integration() {\n    use std::process::Command;\n    \n    let output = Command::new(\"cargo\")\n        .args([\"run\", \"--\", \"debug\", \"cass\"])\n        .output()\n        .expect(\"Failed to run prv\");\n    \n    let stdout = String::from_utf8_lossy(\u0026output.stdout);\n    \n    // Should either connect or show clear error\n    assert!(\n        stdout.contains(\"Connected\") || \n        stdout.contains(\"CASS not available\")\n    );\n}\n```\n\n---\n\n## Verification Checklist\n- [ ] Tests written and fail (no implementation yet)\n- [ ] `prv debug cass` shows connection status\n- [ ] Shows workspace and session counts\n- [ ] Extracts code blocks from sample message\n- [ ] Clear error if CASS not installed\n\n---\n\n## Exit Criteria (Phase 0 Complete)\nWhen this bead passes, Phase 0 is done:\n- [ ] Cargo workspace builds\n- [ ] CASS models defined\n- [ ] Database connection works\n- [ ] Code block parser works\n- [ ] Integration verified via this command","status":"closed","priority":1,"issue_type":"task","assignee":"BlackCat","created_at":"2025-12-27T22:46:13.58871-05:00","updated_at":"2025-12-28T12:22:38.586481-05:00","closed_at":"2025-12-28T12:22:38.586481-05:00","dependencies":[{"issue_id":"PRV-u0f.9","depends_on_id":"PRV-u0f","type":"parent-child","created_at":"2025-12-27T22:46:13.589353-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.9","depends_on_id":"PRV-u0f.3","type":"blocks","created_at":"2025-12-27T22:47:20.777889-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.9","depends_on_id":"PRV-u0f.7","type":"blocks","created_at":"2025-12-27T22:47:25.896613-05:00","created_by":"burdo"},{"issue_id":"PRV-u0f.9","depends_on_id":"PRV-u0f.8","type":"blocks","created_at":"2025-12-27T22:47:31.027248-05:00","created_by":"burdo"}]}
